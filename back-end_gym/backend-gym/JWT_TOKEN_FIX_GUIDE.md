# üîß Guide de correction - Token JWT - Probl√®me senderId

## üö® Probl√®me identifi√©

**Probl√®me c√¥t√© frontend :**

- Le token JWT contenait l'email dans le champ `sub` au lieu de l'ID utilisateur
- Cela emp√™chait le frontend d'identifier correctement l'exp√©diteur des messages
- Le frontend s'attendait √† recevoir l'ID utilisateur dans le token pour identifier les exp√©diteurs

**Cause racine :**

- Le token JWT utilisait l'email comme `subject` au lieu de l'ID utilisateur
- Les autres fonctionnalit√©s utilisaient l'email pour l'authentification
- Il fallait ajouter l'ID utilisateur sans casser l'existant

---

## ‚úÖ Corrections apport√©es

### **1. Mise √† jour de JwtUtils.java**

**Fichier :** `src/main/java/com/gymcoach/backend_gym/security/JwtUtils.java`

**Changements :**

- ‚úÖ Nouvelle m√©thode `generateToken(Long userId, String email, String role)` avec ID dans `sub`
- ‚úÖ Conservation de l'ancienne m√©thode `generateToken(String email)` pour compatibilit√©
- ‚úÖ Nouvelle m√©thode `getUserIdFromToken(String token)` pour extraire l'ID
- ‚úÖ Nouvelle m√©thode `getRoleFromToken(String token)` pour extraire le r√¥le
- ‚úÖ Mise √† jour de `getEmailFromToken(String token)` pour g√©rer les deux formats

```java
// Nouveau format : ID dans 'sub', email et role dans des claims s√©par√©s
public String generateToken(Long userId, String email, String role) {
    return Jwts.builder()
        .setSubject(String.valueOf(userId))  // ID dans 'sub' (frontend expectation)
        .claim("email", email)               // Email dans un claim s√©par√©
        .claim("role", role)                 // R√¥le dans un claim s√©par√©
        .setIssuedAt(now)
        .setExpiration(new Date(now.getTime() + jwtExpirationMs))
        .signWith(getSigningKey(), SignatureAlgorithm.HS256)
        .compact();
}

// Ancien format : email dans 'sub' (compatibilit√©)
public String generateToken(String email) {
    return Jwts.builder()
        .setSubject(email)  // Email dans 'sub' (ancien format)
        .setIssuedAt(now)
        .setExpiration(new Date(now.getTime() + jwtExpirationMs))
        .signWith(getSigningKey(), SignatureAlgorithm.HS256)
        .compact();
}
```

### **2. Mise √† jour de AuthResponse.java**

**Fichier :** `src/main/java/com/gymcoach/backend_gym/dto/AuthResponse.java`

**Changements :**

- ‚úÖ Ajout du champ `userId` dans la r√©ponse de login
- ‚úÖ Conservation de tous les champs existants pour compatibilit√©

```java
public class AuthResponse {
    private String token;
    private String email;
    private String message;
    private String role;
    private String firstName;
    private String lastName;
    private Long userId; // Nouveau champ pour l'ID utilisateur
}
```

### **3. Mise √† jour de AuthServiceImpl.java**

**Fichier :** `src/main/java/com/gymcoach/backend_gym/service/impl/AuthServiceImpl.java`

**Changements :**

- ‚úÖ Utilisation du nouveau format de token avec ID utilisateur
- ‚úÖ Inclusion de l'ID utilisateur dans la r√©ponse de login

```java
@Override
public AuthResponse login(LoginRequest req) {
    // ... validation existante ...

    // G√©n√©rer le token avec le nouveau format (ID dans 'sub', email et role dans des claims)
    String token = jwtUtils.generateToken(user.getId().longValue(), user.getEmail(), user.getRole());

    AuthResponse response = new AuthResponse();
    response.setToken(token);
    response.setEmail(user.getEmail());
    response.setMessage(message);
    response.setRole(user.getRole());
    response.setFirstName(user.getFirstName());
    response.setLastName(user.getLastName());
    response.setUserId(user.getId().longValue()); // Nouveau champ
    return response;
}
```

### **4. Mise √† jour de ChatController.java**

**Fichier :** `src/main/java/com/gymcoach/backend_gym/controller/ChatController.java`

**Changements :**

- ‚úÖ Ajout de `JwtUtils` dans les d√©pendances
- ‚úÖ Mise √† jour de `getCurrentUserId()` pour utiliser le nouveau format de token
- ‚úÖ Fallback vers l'ancienne m√©thode si le nouveau format √©choue

```java
private String getCurrentUserId() {
    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
    if (authentication != null && authentication.getPrincipal() != null) {
        // Essayer d'abord de r√©cup√©rer l'ID depuis le token JWT
        try {
            if (authentication.getCredentials() instanceof String) {
                String token = (String) authentication.getCredentials();
                Long userId = jwtUtils.getUserIdFromToken(token);
                if (userId != null) {
                    return String.valueOf(userId);
                }
            }
        } catch (Exception e) {
            // En cas d'erreur, continuer avec la m√©thode existante
        }

        // M√©thode de fallback : r√©cup√©rer l'email et chercher l'utilisateur
        String email = authentication.getName();
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("Utilisateur non trouv√©"));
        return String.valueOf(user.getId());
    }
    throw new RuntimeException("Utilisateur non authentifi√©");
}
```

### **5. Tests d'int√©gration**

**Fichier :** `src/test/java/com/gymcoach/backend_gym/security/JwtUtilsTest.java`

**Tests ajout√©s :**

- ‚úÖ Test de g√©n√©ration de token avec ID utilisateur
- ‚úÖ Test de g√©n√©ration de token avec email (compatibilit√©)
- ‚úÖ Test d'extraction d'email depuis les deux formats
- ‚úÖ Test d'extraction d'ID utilisateur depuis le nouveau format
- ‚úÖ Test d'extraction de r√¥le depuis le nouveau format

---

## üìã Format de token avant/apr√®s

### **Avant la correction :**

```json
{
  "sub": "user@example.com",
  "iat": 1640995200,
  "exp": 1641081600
}
```

### **Apr√®s la correction :**

```json
{
  "sub": "123",
  "email": "user@example.com",
  "role": "COACH",
  "iat": 1640995200,
  "exp": 1641081600
}
```

---

## üß™ Tests de validation

### **1. Test de g√©n√©ration de token**

```bash
POST /api/auth/login
{
  "email": "test@example.com",
  "password": "password"
}
```

**R√©ponse attendue :**

```json
{
  "token": "eyJhbGciOiJIUzI1NiJ9...",
  "email": "test@example.com",
  "role": "COACH",
  "firstName": "John",
  "lastName": "Doe",
  "userId": 123,
  "message": null
}
```

### **2. Test de d√©codage c√¥t√© frontend**

Le frontend peut maintenant d√©coder le token et obtenir :

- `sub` : ID de l'utilisateur (123)
- `email` : Email de l'utilisateur (test@example.com)
- `role` : R√¥le de l'utilisateur (COACH)

### **3. Test des fonctionnalit√©s existantes**

- ‚úÖ Authentification continue de fonctionner
- ‚úÖ Les tokens existants sont toujours valides
- ‚úÖ Migration progressive sans rupture

---

## üîÑ Migration s√©curis√©e

### **1. Compatibilit√© maintenue**

- ‚úÖ Les tokens existants continuent de fonctionner
- ‚úÖ L'ancien format est toujours support√©
- ‚úÖ Fallback automatique vers l'ancienne m√©thode

### **2. Validation hybride**

```java
public String getEmailFromToken(String token) {
    try {
        // Essayer d'abord le nouveau format (email dans claim)
        Claims claims = parseClaims(token);
        String email = claims.get("email", String.class);
        if (email != null) {
            return email;
        }
        // Fallback vers l'ancien format (email dans 'sub')
        return claims.getSubject();
    } catch (Exception e) {
        return parseClaims(token).getSubject();
    }
}
```

### **3. Extraction d'ID utilisateur**

```java
public Long getUserIdFromToken(String token) {
    try {
        Claims claims = parseClaims(token);
        String subject = claims.getSubject();
        // V√©rifier si le subject est un nombre (ID) ou un email
        try {
            return Long.valueOf(subject);
        } catch (NumberFormatException e) {
            // Ancien format : email dans 'sub', pas d'ID disponible
            return null;
        }
    } catch (Exception e) {
        return null;
    }
}
```

---

## üöÄ D√©ploiement

### **1. Red√©marrage du backend**

```bash
mvn spring-boot:run
```

### **2. Test de l'API de login**

```bash
curl -X POST "http://localhost:8080/api/auth/login" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password"
  }'
```

### **3. V√©rification du token**

D√©codez le token sur jwt.io pour v√©rifier que :

- `sub` contient l'ID utilisateur
- `email` contient l'email
- `role` contient le r√¥le

---

## üîç V√©rification c√¥t√© frontend

### **1. D√©codage du token**

```javascript
// Dans la console du navigateur
const token = "eyJhbGciOiJIUzI1NiJ9...";
const payload = JSON.parse(atob(token.split(".")[1]));
console.log("User ID:", payload.sub);
console.log("Email:", payload.email);
console.log("Role:", payload.role);
```

### **2. Mise √† jour du frontend**

Le frontend peut maintenant utiliser :

- `payload.sub` pour l'ID utilisateur
- `payload.email` pour l'email
- `payload.role` pour le r√¥le

---

## ‚úÖ Checklist de validation

- [ ] Backend red√©marr√© avec succ√®s
- [ ] API `/api/auth/login` retourne `userId` dans la r√©ponse
- [ ] Token JWT contient l'ID utilisateur dans `sub`
- [ ] Token JWT contient l'email dans le claim `email`
- [ ] Token JWT contient le r√¥le dans le claim `role`
- [ ] Tests d'int√©gration passent
- [ ] Frontend peut identifier correctement les exp√©diteurs
- [ ] Aucune r√©gression dans les fonctionnalit√©s existantes
- [ ] Tokens existants continuent de fonctionner

---

## üéØ R√©sultat attendu

**Probl√®me r√©solu :**

- ‚úÖ Le token JWT contient maintenant l'ID utilisateur dans le champ `sub`
- ‚úÖ Le frontend peut identifier correctement l'exp√©diteur de chaque message
- ‚úÖ L'email et le r√¥le restent accessibles via des claims s√©par√©s
- ‚úÖ Compatibilit√© maintenue avec l'ancien format de token

**Fonctionnalit√©s pr√©serv√©es :**

- ‚úÖ Authentification JWT
- ‚úÖ Tokens existants valides
- ‚úÖ Extraction d'email depuis les deux formats
- ‚úÖ Migration progressive sans rupture

---

## üîß Avantages de cette approche

‚úÖ **Compatibilit√©** : Les tokens existants continuent de fonctionner
‚úÖ **Frontend corrig√©** : Le champ `sub` contient maintenant l'ID
‚úÖ **Email pr√©serv√©** : L'email reste accessible via le claim `email`
‚úÖ **Migration progressive** : Pas de rupture de service
‚úÖ **Rollback possible** : Facile de revenir en arri√®re si n√©cessaire
‚úÖ **Tests complets** : Validation de tous les cas d'usage

---

**üí° Note :** Cette correction est r√©trocompatible. Les nouveaux tokens utilisent le format attendu par le frontend, tandis que les anciens tokens continuent de fonctionner gr√¢ce au syst√®me de fallback.
